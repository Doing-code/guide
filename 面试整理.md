## JVM

### 介绍一下JVM内存模型，以及这些空间存放哪些内容?

答：

- JVM内存模型中能接触到的主要有三块区域：
  
  - 堆、方法区、栈。

- JDK1.7：
  
  - 堆：此内存区域的唯一目的就是存放对象实例（new）。包括字符串常量池、静态变量
  
  - 方法区：方法区域在逻辑上是堆的一部分，永久代是实现。永久代占用了堆的空间（且永久代GC也会触发堆的GC）。方法区会存储已被虚拟机加载的类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法（类的构造器）
  
  - 栈 ：由一个个栈帧（方法运行时需要的内存）组成。而栈帧又包括：局部变量表、操作数栈、动态链接、方法返回地址等。
  
  - 程序计数器：程序计数器可以看作是当前线程所执行的字节码的行号指示器。

- JDK1.8：
  
  - 堆：此内存区域的唯一目的就是存放对象实例（new）。包括字符串常量池、静态变量
  
  - 方法区：元空间是实现，使用本地内存而非虚拟机内存。方法区会存储已被虚拟机加载的类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法（类的构造器）
  
  - 栈 ：由一个个栈帧（方法运行时需要的内存）组成。而栈帧又包括：局部变量表、操作数栈、动态链接、方法返回地址等。
  
  - 程序计数器：程序计数器可以看作是当前线程所执行的字节码的行号指示器。

JDK7方法区使用的是永久代（JVM内存），同时在JDK7中将原本在永久代的静态变量和字符串常量池搬移到了堆上。

JDK8将永久代改为元空间，使用的是本地内存（操作系统内存），相对于JVM内存，本地内存空间更大，更不容易出现OOM（本地内存不受JVM GC管理）

堆内存区域的唯一目的就是存放对象实例（new），几乎所有的对象实例以及数组都在这里分配内存（逃逸分析可以在栈上分配内存）

#### JDK 1.7 为什么要将字符串常量池移动到堆中？

答：主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

### 简述内存溢出的原因，如何排查线上问题，如何解决线上GC频繁问题?

### 介绍一下垃圾回收算法，项目中如何选择?

答： 标记-清除（Mark-Sweep，适合老年代）、复制（Copying，新生代）、标记-整理（Mark-Compact，适合老年代）

如果是要吞吐量优先的，可以选择复制+标记整理（Parallel，ParallelOld）。

如果是要响应时间优先的，可以选择复制+标记清除（ParNew，ConcMarkSweep）。

如果想要两者同时兼具，可以选择复制+标记整理（G1：整体上是标记+整理算法，但两个区域之间是复制算法）。适用于超大堆的场景。

### JVM为什么要增加元空间，带来了什么好处?

答：在JDK7的时候永久代GC也会触发堆的GC，这是因为老年代和永久代的垃圾回收器进行了捆绑，无论谁内存不足都会触发永久代和老年代的GC。本来老年代内存很充裕，但是因为永久代的内存频繁不足，造成老年代的GC，Full GC会造成STW（Stop the world）

而JDK8将永久代替换为元空间，元空间使用本地内存（操作系统内存），本地内存不受JVM垃圾回收管理。更不容易产生OOM。

且永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。

### Full GC了解吗?

答：Full GC是整堆收集，不仅要回收新生代，还要回收老年代，性能较低。Full GC会引发STW（Stop the world：暂停其它用户线程，等待垃圾回收结束，用户线程才能恢复运行。）

拿CMS举例，当老年代内存不足，会先触发Minor GC，内存还不足则会触发老年代GC（Major GC）。但是当并发清理阶段产生的浮动垃圾超过了cms设定的预留空间，则会退化为SerialOld（串行 Full GC），

触发时机：

1. 调用System.gc时，建议执行Full GC，不一定会执行；

2. 老年代空间不足；

3. 方法区空间不足（JDK1.7）；

4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存

### 老年代的数据是从哪里来的，CMS作用在哪个代上?

答：老年代的数据主要来自新生代中经过多次的垃圾回收仍然存活的对象（当对象年龄超过阈值时，会晋升至老年代，默认晋升阈值是15，可通过`-XX:MaxTenuringThreshold=threshold`修改默认值），以及大对象（大于指定阈值）的直接分配。

在新生代中经过多次的垃圾回收后，仍然存活的对象会被晋升到老年代，因为新生代的存活对象通常较少，将较为稳定的对象放入老年代有助于减少新生代的垃圾回收频率。

CMS是一种以获取最短回收停顿时间为目标的垃圾回收器，其特点是在垃圾回收过程中尽量减少应用程序的停顿时间，以保证系统的吞吐量和响应速度。

它通过并发标记和并发清除两个阶段来完成垃圾回收，其中并发标记阶段和应用程序线程同时执行，而并发清除阶段需要停止应用程序线程，但时间较短。CMS主要关注老年代的回收，通过并发标记和并发清除来最大限度地减少垃圾回收对应用程序的影响。同时，新生代的回收由其他垃圾回收器（如ParNew）负责。

### 介绍一下对象的创建过程?

```java
// 方法区  栈       堆
   Person p1 = new Person();
```

答：

1. 类加载：当Java虚拟机需要使用一个类时，会首先检查是否已经加载过该类。如果尚未加载，则会通过类加载器加载该类的二进制字节码文件，并在内存中创建一个Class对象来表示该类。
   
   - 加载：加载字节码文件到内存中，并存储在方法区的运行时常量池中，然后将其转换为一个与目标类型对应的java.lang.Class对象实例。
   
   - 链接：防止恶意代码的执行。
     
     - 验证：确保 Class 文件的字节流中包含的信息符合约束要求。
     
     - 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，并为类中的所有静态变量分配内存空间。（静态变量，默认值；被final修饰的static变量（常量），会直接赋值）
     
     - 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。（举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。）
   
   - 初始化：执行static代码块，为静态变量赋值

> 最终，方法区会存储当前类类信息，包括类的静态变量、类初始化代码（定义静态变量时的赋值语句 和 静态初始化代码块）、实例变量定义、实例初始化代码（定义实例变量时的赋值语句实例代码块和构造方法）和实例方法，还有父类的类信息引用。

2. 分配内存：在类加载完成后，Java虚拟机会为对象在堆内存中分配空间。根据对象的大小和特定的内存分配算法，Java虚拟机会选择合适的内存区域来分配对象。

3. 初始化实例变量：在分配内存后，Java虚拟机会将对象的实例变量初始化为默认值，例如，整型变量会被初始化为0，引用类型变量会被初始化为null。

4. 设置对象头：Java虚拟机会在对象的内存空间中额外保存一些信息，例如对象的类型、同步锁状态、GC标记等。这些信息组成了对象头。

5. 执行构造函数：在对象的实例变量初始化完成后，Java虚拟机会调用对象的构造函数来对对象进行进一步的初始化，例如，为实例变量赋予特定的初值或执行其他初始化操作。（`{}`也会得到执行，但原始构造方法内的代码总是最后执行）

6. 对象创建完成。

### 介绍一下类加载的详细过程?

答：

> 加载 -> 链接（验证 -> 准备 -> 解析） -> 初始化

1. 加载：类加载的第一步是加载类的字节码文件。当Java程序需要使用一个类时，Java虚拟机会通过类加载器查找该类的字节码文件，并将其加载到内存中。字节码文件可以来自本地文件系统、网络、ZIP文件等。

2. 验证：在加载字节码文件到内存之前，Java虚拟机会对字节码文件进行验证，以确保其符合Java虚拟机规范和安全性要求。验证过程包括文件格式验证、元数据验证、字节码验证和符号引用验证等。

3. 准备：在准备阶段，Java虚拟机为**类的静态变量**分配内存，并初始化为默认值（例如，数值类型初始化为0，对象引用初始化为null等）。注意，这里只是分配内存，并不会进行赋值操作。

4. 解析：解析阶段是将类的符号引用转换为直接引用的过程。符号引用是指用类的全限定名来表示类、方法、字段等的引用，而直接引用是指指向内存中实际对象的指针或偏移量。解析过程将符号引用解析为直接引用，以便在后续的运行期间直接使用。

5. 初始化：在准备阶段，Java虚拟机为类的静态变量赋予默认值，在初始化阶段，才会执行类的静态初始化代码块。静态初始化代码块是类中用static关键字声明的代码块，用于初始化类的静态变量。初始化阶段是类加载过程的最后一步，也是类加载的触发点。

### 引用和对象分别是什么时候被GC的?

答：

- 对象的GC时机：
  
  - 当对象不再被任何活动线程引用时，即对象不可达时，垃圾回收器会标记该对象为垃圾，并在适当的时机进行回收。Java虚拟机中的垃圾回收器会通过跟踪引用链来判断对象是否可达，如果对象不可达，则认为该对象是垃圾，可以被回收。

- 引用的GC时机：引用指的是指向对象的指针，它们可以被用于检测对象是否还存活。Java中有四种类型的引用：强引用、软引用、弱引用和虚引用。（实际上是五种，还有终结器引用）不同类型的引用在GC时机上有所区别。
  
  - **强引用（Strong Reference）**：如果一个对象有强引用与之关联，即使在内存不足时，垃圾回收器也不会回收该对象，保证对象不会被GC。只有当所有强引用都不存在时，该对象才会被回收。
  
  ```java
  Object strongReference = new Object();
  ......
  strongReference = null;
  ```
  
  - **软引用（Soft Reference）**：当内存不足时，垃圾回收器可能会回收被软引用引用的对象。软引用通常用于实现内存敏感的缓存等场景。配合引用队列使用可以回收引用本身。
  
  ```java
  String str = new String("abc");
  SoftReference<String> softReference = new SoftReference<String>(str);
  ```
  
  - **弱引用（Weak Reference）**：弱引用与软引用类似，但更弱一些。即使内存不紧张，只要垃圾回收器发现某个对象只有弱引用与之关联，就会将该对象回收。配合引用队列使用可以回收引用本身。
  
  ```java
  String str = new String("abc");
  WeakReference<String> weakReference = new WeakReference<>(str);
  ```
  
  - **虚引用（Phantom Reference）**：虚引用是最弱的一种引用，它不能用于获取对象的实例，也不能通过虚引用来获取对象的引用。虚引用的目的是在对象被回收时，收到一个系统通知。必须配合引用队列使用。
  
  ```java
  String str = new String("abc");
  ReferenceQueue queue = new ReferenceQueu();
  // 创建虚引用，要求必须与一个引用队列关联
  PhantomReference pr = new PhantomReference(str,queue);
  ```

### 介绍一下GC过程以及为什么要分代GC?

答：以CMS垃圾回收器为例说一下GC过程。CMS采用复制（新生代）+标记清除（老年代）。

- 老年代GC：
  
  - 1、 初始标记：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快；
  
  - 2、 并发标记：同时开启 GC 和用户线程，用一个闭包结构（可以是图、链表、树等形式）去记录可达对象。在这个阶段，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
  
  - 3、 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段的时间稍长，但远远比并发标记阶段时间短。
  
  - 4、 并发清理：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

分代GC是一种优化策略，将Java堆内存划分为不同的代（Generation），并根据对象的生命周期将对象分配到不同的代中。通常将Java堆分为新生代（Young Generation）、老年代（Old Generation）和永久代（Permanent Generation，JDK1.7）。

而分代GC的原因是大部分对象的生命周期是短暂的，只有少部分对象会存活较长时间。通过将对象分配到不同的代中，可以针对不同代采取不同的垃圾回收策略，从而提高垃圾回收的效率。

比如新生代使用复制算法进行回收，因为新生代对象的生命周期短，复制算法可以迅速回收垃圾。而老年代使用标记-清除或标记-整理算法进行回收，因为老年代对象的生命周期长，需要较为复杂的算法来回收垃圾。

分代GC的优势在于可以根据对象的生命周期采用不同的回收策略，从而提高垃圾回收的效率和性能。同时，分代GC还可以避免全局垃圾回收导致的长时间停顿，提高应用程序的响应速度。

### 介绍一下G1和CMS?

答：

- G1（Garbage-First）：同时注重吞吐量和低延迟，适用于超大堆内存，整体上是标记+整理算法，但两个区域之间是复制算法。
  
  - 大致分为四个步骤：初始标记（stw）、并发标记、最终标记（stw）、筛选回收（stw）。

- CMS（Concurrent Mark Sweep）收集器是一种尽可能让单次STW的时间最短的收集器。
  
  - 优点：并发收集、低停顿。
  
  - 缺点：
    
    - 对 CPU 资源敏感
    
    - 无法处理浮动垃圾
    
    - 它使用的回收算法-`标记-清除`算法会导致收集结束时会有大量空间碎片产生

## JUC

### 简述线程安全的活跃性问题，竞态条件是怎么产生的，如何避免死锁?

答：

1. 线程安全的活跃性问题主要涉及三类问题：死锁、活锁和饥饿。
   
   - 死锁：死锁是指两个或多个线程相互等待对方释放锁，导致程序无法继续执行的情况。
   
   - 活锁：两个线程改变对方的结束条件。线程之间存在竞争条件，导致资源的状态不断变化，使得线程无法成功获取资源。
   
   - 饥饿：生产者生产速度跟不上消费者消费速度。

2. 多个线程在临界区（一段代码块内如果存在对共享资源的多线程读写操作，则称这段代码块为临界区）内执行，由于代码的执行序列不同而导致结果无法预测。

3. 破坏锁竞争、避免使用多把锁、顺序加锁、避免嵌套锁、使用JUC并发工具包（如ReentrantLock.tryLock()）...

### 说明线程状态切换?

答：

1. `NEW`：线程对象被创建，但还没有调用start()方法启动线程。

2. `RUNNABLE`：线程调用start()方法后，进入可运行状态，表示线程正在JVM中运行或等待CPU时间片。

3. `BLOCKED`：等待IO操作、等待获取锁等。

4. `WAITING`：
   
   - 进入`WAITING`：wait()、join()、park()...
   
   - 进入`BLOCKED`：调用notify()、notifyAll()、interrupt()唤醒后，但是竞争锁失败。
   
   - 回到`RUNNABLE`：notify()、notifyAll()、interrupt()、unppark()...

5. `TIMED_WAITING`
   
   - 进入`TIMED_WAITING`：wait(n)、join(n)、sleep(n)、parkNanos()、parkUnit()...
   
   - 进入`BLOCKED`：调用notify()、notifyAll()、interrupt()唤醒后，但是竞争锁失败。
   
   - 回到`RUNNABLE`：notify()、notifyAll()、interrupt()、unppark()...

6. `TERMINATED`：线程执行完了所有的代码或者发生了未捕获的异常导致线程终止。

### 多少线程合适，在项目中如何考虑?

答：

1. CPU 密集型运算：通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶替，保证 CPU 的时钟周期不被浪费。

2. IO 密集型运算：经验公式：`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间`。（简单理解就是2n（n是CPU核数））

### 说明synchronized底层实现，以及和Lock的区别?

答：

synchronized的底层实现主要涉及对象头和monitor锁。

从字节码角度说的话，底层使用（管程或者叫监视器）monitorenter、monitorexit将同步块包起来。

将Monitor与锁对象关联。将Owner设置为抢占到锁的线程，后续再有线程来获取锁，先进入EntryList等待。在WaitSet中等待的线程，如果条件满足了则会进入EntryList等待获取锁。

优化：更底层一点就是，在对象头添加一些标记位来表示锁的状态。无锁的标记位是001，偏向锁的标记位是101，轻量级锁的标记位是00，重量级锁的标记位是10。

- 偏向锁会将线程ID设置到对象的 Mark Word 中。

- 轻量级锁会在当前线程的栈帧创建一块空间用于存储锁记录（lock record），把对象头中的Mark Word复制到锁记录中，拷贝成功后，虚拟机将使用CAS操作将对象Mark Word更新为指向Lock Record的指针。并将Lock Record里的owner指针指向对象的Mark Word。

与 synchronized 一样，都支持可重入。但不同的是ReentrantLock支持可中断、可以设置超时时间、可以设置公平锁、支持多个条件变量。且ReentrantLock是基于AQS（AbstractQueuedSynchronizer）实现的

而 AQS 是用 CLH（Craig,Landin,and Hagersten） 队列锁 实现的。

### 说明ThreadLocal的底层实现，以及实现的数据结构?

答：

每个Thread对象都有一个关联的ThreadLocalMap，用于存储ThreadLocal变量与线程局部变量值之间的映射关系。（数组下标：`key.threadLocalHashCode & (len-1)`）

ThreadLocalMap中的每个映射关系都被封装为一个Entry对象，它包含了ThreadLocal实例（弱引用）作为键，以及线程局部变量的值作为值。一个ThreadLocal实例可以对应多个Thread的局部变量，因此需要通过线程对象来进行区分。

为了防止内存泄漏，ThreadLocalMap使用ThreadLocal实例的弱引用作为键。这样，当ThreadLocal实例没有其他强引用时，它可以被垃圾回收，从而避免内存泄漏问题。

ThreadLocalMap采用线性探测法解决哈希冲突，当发生哈希冲突时，会线性地查找下一个可用的槽位。

通过ThreadLocal的get()方法可以获取当前线程的局部变量值。如果当前线程没有设置过该ThreadLocal，则会通过initialValue()方法初始化一个默认值。通过ThreadLocal的set()方法可以设置当前线程的局部变量值。

ThreadLocalMap中的映射关系存在一定的生命周期，当线程结束或者ThreadLocal实例没有强引用时，相关的映射关系会变为垃圾。但是，由于线程结束不一定会立即触发垃圾回收，因此在使用完ThreadLocal后，最好手动调用remove()方法来清理，以避免潜在的内存泄漏。

**ThreadLocal的数据结构大致如下**：

```less
ThreadLocal
   ↓
ThreadLocalMap
   ↓
Entry (key: ThreadLocal, value: variable value)
```

### volatile的可见性和禁止指令重排是怎么实现的，有几种屏障?

答：

volatile的可见性和禁止指令重排是内存屏障（Memory Barrier）来实现的。**在写入volatile变量之后**，会插入一个写内存屏障，确保写操作对其他线程可见。**在读取volatile变量之前**，会插入一个读内存屏障，确保读操作获取最新的值。

> 指令重排是编译器和处理器为了提高性能而进行的优化。即同一个线程内，JVM 在不会改变程序结果的前提下，可以调整语句的执行顺序。这些指令的各个阶段可以通过重排序和组合来实现指令级并行。

在Java中，有两种内存屏障：

- **Load Barrier（读屏障）**：确保在读取操作之前，所有的读取操作都已经完成。它防止后续的读取操作重排到读取操作之前，从而保证读取的是最新的值。

- **Store Barrier（写屏障）**：确保在写入操作之前，所有的写入操作都已经完成。它防止前面的写入操作重排到写入操作之后，从而保证写入的值对其他线程可见。

### 说明ConcurrentHashMap的底层原理?

答：

- ConcurrentHashMap在JDK7的实现中（默认构造就会初始化，Segment继承自ReentrantLock）：
  
  - 分段锁（Segment Lock）：ConcurrentHashMap将整个哈希表分成多个段（Segment），每个段都维护了一个小的哈希表。不同的线程可以同时访问不同的段，从而降低了锁竞争的激烈程度，提高了并发性能。
  
  - Hash桶：每个段内部使用哈希桶（Hash Bucket）来存储键值对。哈希桶是一个链表数组，每个链表存储了哈希值相同的键值对。
  
  - 扩容机制：Segment数组默认容量16，且不会再扩容；而HashEntry默认容量2，会扩容。
  
  - put操作：在执行put操作时，先根据键的哈希值找到对应的段，然后再在段内的哈希桶中插入或更新键值对。在插入或更新时，会使用分段锁来保证线程安全性。
  
  - get操作：在执行get操作时，同样先根据键的哈希值找到对应的段，然后再在段内的哈希桶中查找对应的值。由于每个段都有自己的锁，多个线程可以并发地执行get操作。

- ConcurrentHashMap在JDK8的实现中（懒加载，第一次put才初始化）：
  
  - 取消了分段锁机制，JDK7可以看作是一个二级数组，而JDK8改为了一级数组，hash冲突时只锁链表head节点。在非hash冲突时使用CAS保证线程安全
  
  - 桶数组可以容量，与HashMap无异，只不过方法有些许差异。

### 说明线程池创建的流程?

答：

1. 创建线程池对象：创建ThreadPoolExecutor的实例，并设置线程池的核心线程、最大线程、空闲线程存活时间、阻塞队列、线程工厂、拒绝策略等参数。

2. 提交任务：通过线程池的 execute(Runnable task) 方法提交任务，线程池会自动调度线程来执行任务。

3. 若超过核心线程数，则进入阻塞队列等待，若阻塞队列满了，则创建临时线程处理新添加的任务。若超过最大线程，则会根据拒绝策略处理新任务。

4. 线程池监控线程，确保空闲线程得到回收。

5. 优雅关闭线程池，会等待已提交的任务执行完毕后关闭线程池。

### 用过线程池吗?

答：没用过。

## 网络通信

### 怎么样才能确定一个连接?

答：

四元组：在TCP协议中，如何去确定一个客户端连接的组成要素。包括: **源IP地址，目标IP地址，源端口号，目标端口号**。

当一个客户端和服务端建立一个TCP连接是，通过四元组来确定唯一的一个TCP连接。

### 说明一下一个请求的完整流程?

答（以HTTP为例）：

1. 发起请求：客户端（例如浏览器、移动应用等）向服务端发送请求。请求包括目标资源的 URL、HTTP 方法（如 GET、POST）、请求头（包含各种元信息）、请求体（对于 POST 请求）、Cookies 等。

2. 域名解析：如果请求的 URL 是域名形式，客户端需要将域名解析为对应的 IP 地址。这一步需要通过 DNS（Domain Name System）进行域名解析。

3. 建立连接：客户端与服务端建立连接。通过TCP协议与服务器建立连接。这包括TCP的三次握手过程。

4. 发送请求：客户端将请求信息发送给服务端。这包括发送请求头、请求体等数据。

5. 服务端处理：服务端接收到请求后，根据请求的内容进行处理。这可能涉及到数据库查询、业务逻辑处理、权限验证等操作。

6. 返回响应：服务端将处理结果封装成响应信息发送给客户端。响应包括状态码、响应头、响应体等信息。

7. 接收响应：客户端接收到响应后，根据响应的内容进行处理。这可能包括解析响应数据、渲染页面、处理业务逻辑等。

8. 关闭连接：在请求-响应过程完成后，客户端和服务端会关闭连接，释放资源。如果连接是持久连接（HTTP/1.1的默认行为），连接可能会被保持以备后续请求使用。

### TCP为什么要三次握手，两次不行吗?

答：TCP采用三次握手的原因是为了确保双方的通信能够稳定建立，并且防止已失效的连接请求被错误地接受。

> TODO 未完待续...

### TCP粘包是怎么产生的，如何解决?

答： 

粘包：多条数据合并为一条数据发送。接收端一次接受到了多个数据包，而且不保证是多个完整数据包的集合，也许其中某个数据包是不完整的。

原因可能是：接收方ByteBuf设置过大、接收方处理不及时且窗口大小足够大、开启了Nagle算法会造成粘包。本质是因为TCP是流式协议，消息无边界。

解决：短链接、定长解码器、行解码器...

### 介绍一下bio、nio、aio以及Netty的模型?

答：Netty主要基于主从Reactors（IO多路复用的一种实现模式）多线程模型，即MainReactor线程只负责监听客户端连接事件，并将请求转交给SubReactor。SubReactor线程负责IO读写事件等。非IO请求的任务则会直接写入队列，等待worker threads进行处理

![](./image/redis_网络模型_IO比较.png)

### TCP的空白连接占用多少内存?

答：创建 10000 个 TCP socket 会使用 31552 KB 内存，即每个 TCP socket 占用 3.155 KB。

### TCP协议握手挥手，为什么有time_wait?

答：

> TODO 未完待续...

## Netty

### 为什么会有粘包的情况?Netty如何处理粘包半包?

答：

**粘包**：多个独立的消息被粘在一起发送，接收方无法准确判断消息的边界，从而导致多个消息合并在一起。

**半包**：一个消息被分成多个包发送，接收方无法完整地接收到消息。

解决：

固定长度解码器：指定每个消息的固定长度，接收方根据固定长度来分割消息。

行分隔符解码器：根据换行符来分割消息，常用于文本协议。

自定义协议解码器：针对特定的协议，自定义解码器来解析消息。

长度字段解码器：在消息的前面加上表示消息长度的字段，接收方根据长度字段来正确分割消息。

总之，Netty通过合适的解码器机制，可以有效地解决粘包和半包问题，确保数据在网络传输中的正确解析和处理。

### Netty长连接如何做keeplive的?

答：

即心跳机制。Netty通过IdleStateHandler实现的心跳机制，内部使用定时任务来判断是否读/写超时。

IdleStateHandler实现了入站、出站接口，相应地也会重写入站、出站的方法。而记录耗时的逻辑就是在入站、出站的方法中处理的。

## Spring

### Spring自动装配Bean有哪些方式?

答：

1. `@Autowired`（默认按照byType、当有多个实现类时变为byName） + `@Quanifier`（显示指定名称） + `@Primary`（优先级Bean，默认使用这个注解标注的Bean）：

2. `@Resource`（默认byName，无法通过名称匹配Bean时会变为byType） ，`@Inject`（功能和`@Autowired`一样 ）

3. Aware接口，回调方法。

4. `@Profile`，根据环境注册Bean。

### 说明Spring refresh流程?

答：

1. 准备刷新操作：在执行刷新操作之前，首先会调用`prepareRefresh()`方法来准备刷新操作。这个方法会初始化一些刷新所需的状态，比如重置一些计数器、标记等。

2. 初始化Bean工厂：接着会调用`obtainFreshBeanFactory()`方法来创建或获取一个新的Bean工厂实例，用于存储应用程序中所有的Bean定义。

3. 设置BeanFactory的类加载器：调用`prepareBeanFactory()`将Bean工厂的类加载器设置为应用程序的类加载器，以确保Bean可以被正确加载和实例化。

4. 执行BeanFactoryPostProcessors回调：调用`invokeBeanFactoryPostProcessors()`，提供最后一次添加或修改 BeanDefinition 的机会。执行BeanDefinitionRegistryPostProcessor回调可以添加（动态添加BeanDefinition），但执行到BeanFactoryPostProcessors回调时只允许修改

5. 添加BeanPostProcessors：调用`registerBeanPostProcessors()`，将所有注册的BeanPostProcessor（后置处理器）添加到Bean工厂中，这些后置处理器可以在Bean实例化和初始化的过程中进行操作。

6. 初始化消息源：如果应用程序需要国际化消息处理，会调用`initMessageSource()`方法来初始化消息源。

7. 初始化应用事件广播器：初始化应用事件广播器，用于发布应用程序中的各种事件，以及监听并响应这些事件。

8. 初始化应用上下文事件多播器：初始化应用上下文事件多播器，用于将事件传播给已注册的监听器。

9. 初始化剩余的单例Bean：初始化那些在Bean定义中标记为单例作用域的Bean。

10. 完成刷新操作：完成刷新操作，包括发布容器已刷新的事件，以及销毁之前的单例Bean实例（如果有必要）。

### Spring事务失效常见有哪些?

答

1. 未添加@Transactional注解或配置事务管理器：在需要使用事务的方法上没有添加@Transactional注解，或者没有配置事务管理器，导致事务无法生效。

2. 方法未满足事务传播行为要求：事务的传播行为（Propagation）设置不正确，例如在一个已有事务的方法中调用了一个不支持事务的方法，导致事务失效。

3. 异常未被捕获或未抛出：当方法中抛出未被捕获的异常时，事务可能无法回滚，从而导致数据不一致。

4. 事务方法被子类方法调用：在子类中调用父类的事务方法，可能会导致事务失效，因为Spring使用动态代理来实现事务，而子类调用时绕过了代理。

5. 跨越多个数据源的事务：在跨越多个数据源的事务中，如果没有正确配置分布式事务管理，可能会导致事务失效。

6. 同一个类内部的方法调用：同一个类内部的方法调用，默认不会触发Spring的代理机制，因此事务可能失效。可以通过self-invocation属性解决。

......

### Spring中的设计模式有哪些，平时有用到吗?

答 ：

1. 单例模式（Singleton）：Spring 容器中的 Bean 默认是单例的，保证了在应用程序中只存在一个实例，节省资源。

2. 工厂模式（Factory）：Spring 使用工厂模式创建和管理 Bean，通过配置文件或注解来创建对象，降低了耦合性。

3. 代理模式（Proxy）：Spring AOP 使用了代理模式来实现切面编程，可以在不修改源代码的情况下增加额外的功能。

4. 观察者模式（Observer）：Spring 中的事件驱动机制就是基于观察者模式实现的，可以用于组件间的解耦和通信。

......

## SpringBoot

### 说明SpringBoot自动装配原理?

答：

在启动类中使用`@Import`导入了一个组件`AutoConfigurationPackages.Registrar.class`，将启动类所在的包的所有组件导入容器中。

然后又导入了一个组件`AutoConfigurationImportSelector.class`，其作用是读取指定文件`META-INF/spring.factories`中符合条件（`EnableAutoConfiguration`）的全类名。然后再进行筛选将最终结果全部导入到Spring容器中。

配置类是否生效取决于`@ConditionalOnClass`这种`@ConditionalOnXxx`条件注解，如果系统中存在指定的类，那么对应的配置类则生效。就会导入相关的组件。

### 说明SpringBoot的@Condition的实现原理?

答：

首先SpringBoot的`@ConditionOnXxx`是基于Spring的`@Conditional`和`Condition`接口实现的。其作用就是当满足当前条件时，配置的Bean才会生效。

`Condition`接口提供一个matches()方法。用来匹配条件。如`@ConditionalOnMissingBean`、`@ConditionalOnMissingClass`、`@ConditionalOnClass`等注解都由`OnBeanCondition`类进行匹配处理。其实现了`Condition`接口。

Condition接口的matches()方法接收两个参数，一个是ConditionContext，一个是AnnotatedTypeMetadata。获取到注解元数据和Condition的上下文，进行注解信息的匹配。

## MyBatis

### 说明MyBatis的执行流程和底层实现?

答：

- 执行流程：
  
  - 加载配置文件：驼峰命名、缓存、数据库连接池配置等。
  
  - 创建 SqlSessionFactory：解析配置文件，如果配置了插件则添加到插件链集合中，解析mappers配置文件（缓存、sql标签等信息封装成MappedStatement，并添加到mappedStatements集合中），这一步的目的就是将配置文件的信息封装到Configuration类中。作为全局配置类管理。
  
  - 创建 SqlSession：通过 SqlSessionFactory 创建 SqlSession，代表与数据库的一次会话。（根据Configuration存储的配置信息来配置数据库环境、事务管理器、执行器（执行SQL）等）
  
  - 编写 Mapper 接口：编写与数据库操作相关的 Mapper 接口，并在映射文件中配置 SQL 映射关系。
  
  - 执行 SQL：通过 Mapper 接口（代理对象）调用方法，底层由 MyBatis 执行 SQL 查询。
  
  - 数据映射：MyBatis 将查询结果映射到 Java 对象。
  
  - 提交事务：完成数据库操作后，需要显式提交事务（Mybatis默认是手动提交事务的）。

- 底层实现：
  
  - 解析配置文件：MyBatis 首先会解析 mybatis-config.xml 配置文件，获取数据库连接信息、类型处理器、插件等配置。并根据配置文件中的数据源信息，创建数据库连接池和数据库连接等环境。
  
  - 创建 SqlSessionFactory：使用 SqlSessionFactoryBuilder 根据配置文件和环境信息创建 SqlSessionFactory 实例。这一步就是将配置文件配置项封装到Configuration类中。统一管理。
  
  - 创建 SqlSession：通过 SqlSessionFactory 创建 SqlSession，代表与数据库的一次会话。（根据Configuration存储的配置信息来配置数据库环境、事务管理器、执行器（执行SQL）等）
  
  - Mapper 接口代理：MyBatis 使用 JDK 动态代理或 CGLIB 创建 Mapper 接口的代理对象，实现底层 SQL 执行。
  
  - 构建 SQL：Mapper 接口方法的调用将触发底层 SQL 语句的构建，MyBatis 会将映射文件中配置的 SQL 拼接为完整的 SQL 语句。
  
  - 执行 SQL：通过 JDBC 调用底层数据库执行 SQL 查询，获取结果集。
  
  - 结果映射：将查询结果映射为 Java 对象，可以使用 ResultMap 配置来定义映射关系。
  
  - 事务管理：根据事务配置，使用底层的数据库连接或连接池来管理事务的提交和回滚（Mybatis默认是手动提交事务的）。
  
  - 如果配置了插件，MyBatis 支持插件机制，在 SQL 执行前后可以进行拦截和增强。

> 一级缓存默认开启并且无法关闭；二级缓存需要手动开启并进行配置。
> 
> 一级缓存是Session级别，二级缓存是Mapper级别
> 
> 二级缓存则是通过配置 Cache 接口来实现的，且还需实现Serializable接口
> 
> 如果开启了二级缓存，优先查询二级缓存，如果二级缓存没有，则再查询一级缓存，当会话关闭时，会将一级缓存的数据保存到二级缓存中。

### 如果数据库进行修改了，Mybatis的缓存怎么办?

答：

MyBatis 默认使用一级缓存（SqlSession 级别的缓存），当一个 SqlSession 执行了更新操作（例如插入、更新、删除）后，会自动清空一级缓存，以保证缓存数据的一致性。

对于二级缓存（namespace 级别的缓存），当数据库进行修改时，MyBatis 会通过版本号或时间戳等机制来保证缓存的一致性。默认情况下，MyBatis 的二级缓存是不会自动更新的，需要手动设置 `<cache/>` 标签的 `flushInterval` 属性来定时刷新缓存。

## Dubbo

### 介绍一下Dubbo的核心功能?

答：

1. 服务注册与发现：Dubbo 提供了服务注册与发现功能（Zookeeper），可以将服务提供者注册到注册中心，并让消费者从注册中心获取服务提供者的地址，实现动态的服务发现和负载均衡。

2. 远程调用：Dubbo 支持远程方法调用，可以通过 RPC 协议实现跨网络的服务调用，隐藏了底层的通信细节。

3. 负载均衡：Dubbo 内置多种负载均衡策略，可以在消费者端选择合适的负载均衡算法，分配请求到不同的服务提供者。

4. 服务容错：Dubbo 提供了多种服务容错机制，包括失败重试、失败切换、失败降级等，保障系统在一些异常情况下的稳定性。

5. 配置管理：Dubbo 支持服务提供者和消费者的配置管理，可以动态地修改服务的配置参数，而不需要重启应用。

......

### 介绍一下Dubbo的核心组件?

答：

1. 服务提供者（Provider）：服务提供者是提供具体服务实现的一方，将服务实现暴露给消费者调用。服务提供者在启动时会向注册中心注册自己提供的服务。

2. 服务消费者（Consumer）：服务消费者是调用远程服务的一方，它会通过 Dubbo 客户端来发起远程调用请求。消费者会从注册中心获取服务提供者的地址，并选择合适的提供者进行调用。

3. 注册中心（Registry）：注册中心是 Dubbo 的服务注册与发现中心，用于管理服务提供者的地址信息，消费者可以从注册中心获取可用的服务提供者列表。

4. 通信层（Remoting）：Dubbo 支持多种通信协议，包括 Dubbo 协议、HTTP、Hessian、Thrift 等，用于实现服务消费者与提供者之间的远程通信。

5. 监控与治理（Monitor & Admin）：Dubbo 提供了丰富的监控和管理功能，可以统计服务调用信息、性能指标等，用于系统监控和问题定位。

......

> Protocol 远程调用层：封装 RPC 调用。只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用。

### 采用注册中心的好处?

答：

生产者和消费者解耦（因为注册中心主要解决的是服务注册发现问题），生产者和消费者从第三方去获取数据。集群容错。

动态性： 在分布式系统中，服务的数量和状态可能会频繁变化，通过注册中心可以实现实时的服务注册和发现，从而保证系统能够动态适应环境的变化。

负载均衡： Dubbo的注册中心提供了负载均衡的功能，消费者可以从多个可用的服务提供者中选择合适的进行调用，实现负载均衡，降低单个服务提供者的压力。

......

> Dubbo采用注册中心能够简化分布式系统的服务管理和调用，提高系统的可用性、可扩展性和灵活性

### 介绍一下Dubbo的流程以及默认序列化方式?

答：

- Dubbo的基本流程（调用过程中的容错、降级省略了，还有服务端、客户端filter等扩展也省略了）：
  
  - 1、服务提供者将服务注册到注册中心，同时向注册中心报告自己的IP地址和端口号。（服务导出）
  
  - 2、服务消费者从注册中心获取可用的服务提供者列表。（服务引用）
  
  - 3、服务消费者通过负载均衡算法选择一个服务提供者进行远程调用。
  
  - 4、服务消费者通过网络协议将请求发送给选定的服务提供者。
  
  - 5、服务提供者收到请求后，执行相应的逻辑处理，并将结果返回给服务消费者。
  
  - 6、服务消费者收到结果后，进行相应的处理。

- 默认序列化方式：Dubbo默认使用Hessian 2作为其序列化协议。是一种高性能的二进制序列化协议。

### 说一下Dubbo服务的启动、注册流程?

答：

- 服务提供者启动：
  
  - 1、服务配置解析：
    
    - Dubbo会解析服务提供者在XML配置文件或注解中定义的服务配置，包括服务接口、服务实现类、协议、端口等信息。
  
  - 2、服务实例化：
    
    - Dubbo会根据服务实现类的配置信息，实例化服务对象。
  
  - 3、服务包装：
    
    - Dubbo会对服务对象进行包装，以提供一些额外的功能，如事务管理、远程调用的封装等。这些包装类会按照一定的顺序进行包装，形成一个代理链。
  
  - 4、服务注册：
    
    - Dubbo将服务的相关信息注册到注册中心，包括服务接口、服务地址、服务版本等。注册中心可以是ZooKeeper、Consul等。
  
  - 5、协议导出：
    
    - Dubbo会根据配置的协议类型，将服务暴露到指定的协议上，比如Dubbo协议、HTTP协议等。在导出过程中，Dubbo会创建对应的Server对象，并将服务对象和协议绑定起来。
  
  - 6、服务暴露：
    
    - 服务暴露是指将服务发布到网络上（Netty），以供消费者调用。在此阶段，Dubbo会启动监听器，监听指定协议的端口，等待消费者的调用。

- 服务消费者启动：
  
  1. 通过 FactoryBean 或者 afterPropertiesSet() 方法触发服务引用。（懒加载）
  
  2. 连接注册中心，获取服务提供者列表，创建 Invoker。
  
  3. 订阅服务提供者节点，数据变更时监听通知。
  
  4. 连接通信服务器，获得客户端。
  
  5. 创建代理并返回。

## Redis

### Redis底层的数据结构?

答：

基本类型有五种：String、Hash、List、Set、SortSet

非基本类型的就是特殊类型，典型的有：GEO、BitMap、HyperLog

- `String`：底层采用SDS（Simple Dynamic String）动态字符串实现的。在对象头记录了字符串长度、申请的内存长度以及结束标识符。支持扩容。

- `Hash`：
  
    - 默认采用ZipList存储，以节省内存，ZipList中相邻的两个entry分别保存field和value，元素超过512或者任意任一value大小超过了64字节。则Hash结构会从ZipList转为HT（Dict）编码
  
    - 底层采用Dict（数组+链表，发生hash碰撞使用头插法），数据结构类似Java中的HashMap。

- `List`：
  
    - Redis3.2以前默认采用ZipList（特殊的`"双端链表"`），由特定的特殊编码的连续内存块组成，可以在任意一端进行压入/弹出操作，并且该操作的时间复杂度为O(1)，并不是真正意义上的链表，只是具备链表的特性。
      
        - 其对象头记录链表占用字节数、尾节点偏移量以及节点数量。当元素个数大于512并且元素占用大于64字节时采用LinkedList编码。
    
    - Redis3.2以后统一采用QuickList来实现List，它是一个双端链表，只不过链表中的每个节点存储的是ZipList。可以控制ZipList的大小，还可以对节点的ZipList做压缩（控制首尾不压缩的节点个数）
    
- `Set`
  
    - 如果Set中只存储了纯数字，则底层采用IntSet（基于整数组数来实现，具备可变长度、有序（二分查找确定新元素插入到哪个位置）等特征）存储。如果不是纯数字，则还是采用Dict进行数据存储。

- `SortSet`：

    - 当元素较少（元素个数小于128，每个元素都小于64个字节）时，还是会采用ZipList结构来存储，以节省内存。（ZipList没有排序功能，需要ZSet通过业务编码实现，默认升序）
      
    - 采用SkipList + Dict两者配合实现。SkipList（跳表）事实上还是一个链表，但与传统的链表相比有几点差异（元素按照升序排列存储；一个节点可能包含多个指针，指针跨度不同，最多允许32级指针）

### 说一下Redis在项目中的使用?

### 介绍一下缓存雪崩、穿透、击穿的场景和对应的解决方案?（Redis中可能存在的问题）

### 介绍一下缓存一致性的问题?

### Redis会不会丢失数据?

### 介绍一下Redis的主从复制?

### Redis有哪几种缓冲区?

## MySQL

### 说明一下联合索引?

### 说明InnoDB和MylSam的区别，及使用场景?

### 数据库和Redis的一致性问题怎么解决的，如何保证强一致性?

### MySQL中是怎么保证ACID的?

## Kafka

### 为什么用Kafka?

### 如何保证消息的顺序性?

### 如何避免消息的重复消费?

### 延迟消息的使用场景是什么，oneway了解吗?

### 如何解决消息挤压?

## 场景题

### 说一下秒杀的实现?

### 说一下多个系统之间的调用方式以及可能出现的问题?

### 说一下项目中遇到的困难?

### 说一下限流的常见算法?

### 高并发的处理方法?

## 运维

### Linux、CPU以及IO优化都是怎么做的?

### 异地多机房容灾架构怎么保证数据同步?

### 数据冷备份的方案是什么?

### 生产环境上如何快速定位并解决问题?

### 如果一个系统2分钟内的CPU非常大，如何处理，如何解决?

### 项目如何承载高并访问?（架构）

> Nginx负载 + Redis缓存 + 异步处理

## 算法

## 系统指标

## 项目

### 一台机器，Netty能建立多少连接?（结合网关项目：http进，dubbo出，各个能支持多少连接?）

### 网关项目的编解码器如何实现

## 附录

> JDK1.7：-Xss1m -Xms1024m -Xmx2048m -Xmn345m -XX:SurvivorRatio=8 -XX:PermSize=256m -XX:MaxPermSize=512m
> 
> JDK1.8：-Xss1m -Xms1024m -Xmx2048m -Xmn345m -XX:SurvivorRatio=8 -XX:MaxMetaspaceSize=512m 