## JVM

### 介绍一下JVM内存模型，以及这些空间存放哪些内容?

答：

- JVM内存模型中能接触到的主要有三块区域：
  
  - 堆、方法区、栈。

- JDK1.7：
  
  - 堆：此内存区域的唯一目的就是存放对象实例（new）。包括字符串常量池、静态变量
  
  - 方法区：方法区域在逻辑上是堆的一部分，永久代是实现。永久代占用了堆的空间（且永久代GC也会触发堆的GC）。方法区会存储已被虚拟机加载的类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法（类的构造器）
  
  - 栈 ：由一个个栈帧（方法运行时需要的内存）组成。而栈帧又包括：局部变量表、操作数栈、动态链接、方法返回地址等。
  
  - 程序计数器：程序计数器可以看作是当前线程所执行的字节码的行号指示器。

- JDK1.8：
  
  - 堆：此内存区域的唯一目的就是存放对象实例（new）。包括字符串常量池、静态变量
  
  - 方法区：元空间是实现，使用本地内存而非虚拟机内存。方法区会存储已被虚拟机加载的类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法（类的构造器）
  
  - 栈 ：由一个个栈帧（方法运行时需要的内存）组成。而栈帧又包括：局部变量表、操作数栈、动态链接、方法返回地址等。
  
  - 程序计数器：程序计数器可以看作是当前线程所执行的字节码的行号指示器。

JDK7方法区使用的是永久代（JVM内存），同时在JDK7中将原本在永久代的静态变量和字符串常量池搬移到了堆上。

JDK8将永久代改为元空间，使用的是本地内存（操作系统内存），相对于JVM内存，本地内存空间更大，更不容易出现OOM（本地内存不受JVM GC管理）

堆内存区域的唯一目的就是存放对象实例（new），几乎所有的对象实例以及数组都在这里分配内存（逃逸分析可以在栈上分配内存）

#### JDK 1.7 为什么要将字符串常量池移动到堆中？

答：主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

### 简述内存溢出的原因，如何排查线上问题，如何解决线上GC频繁问题?

### 介绍一下垃圾回收算法，项目中如何选择?

答： 标记-清除（Mark-Sweep，适合老年代）、复制（Copying，新生代）、标记-整理（Mark-Compact，适合老年代）

如果是要吞吐量优先的，可以选择复制+标记整理（Parallel，ParallelOld）。

如果是要响应时间优先的，可以选择复制+标记清除（ParNew，ConcMarkSweep）。

如果想要两者同时兼具，可以选择复制+标记整理（G1：整体上是标记+整理算法，但两个区域之间是复制算法）。适用于超大堆的场景。

### JVM为什么要增加元空间，带来了什么好处?

答：在JDK7的时候永久代GC也会触发堆的GC，这是因为老年代和永久代的垃圾回收器进行了捆绑，无论谁内存不足都会触发永久代和老年代的GC。本来老年代内存很充裕，但是因为永久代的内存频繁不足，造成老年代的GC，Full GC会造成STW（Stop the world）

而JDK8将永久代替换为元空间，元空间使用本地内存（操作系统内存），本地内存不受JVM垃圾回收管理。更不容易产生OOM。

且永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。

### Full GC了解吗?

答：Full GC是整堆收集，不仅要回收新生代，还要回收老年代，性能较低。Full GC会引发STW（Stop the world：暂停其它用户线程，等待垃圾回收结束，用户线程才能恢复运行。）

拿CMS举例，当老年代内存不足，会先触发Minor GC，内存还不足则会触发老年代GC（Major GC）。但是当并发清理阶段产生的浮动垃圾超过了cms设定的预留空间，则会退化为SerialOld（串行 Full GC），

触发时机：

1. 调用System.gc时，建议执行Full GC，不一定会执行；

2. 老年代空间不足；

3. 方法区空间不足（JDK1.7）；

4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存

### 老年代的数据是从哪里来的，CMS作用在哪个代上?

答：老年代的数据主要来自新生代中经过多次的垃圾回收仍然存活的对象（当对象年龄超过阈值时，会晋升至老年代，默认晋升阈值是15，可通过`-XX:MaxTenuringThreshold=threshold`修改默认值），以及大对象（大于指定阈值）的直接分配。

在新生代中经过多次的垃圾回收后，仍然存活的对象会被晋升到老年代，因为新生代的存活对象通常较少，将较为稳定的对象放入老年代有助于减少新生代的垃圾回收频率。

CMS是一种以获取最短回收停顿时间为目标的垃圾回收器，其特点是在垃圾回收过程中尽量减少应用程序的停顿时间，以保证系统的吞吐量和响应速度。

它通过并发标记和并发清除两个阶段来完成垃圾回收，其中并发标记阶段和应用程序线程同时执行，而并发清除阶段需要停止应用程序线程，但时间较短。CMS主要关注老年代的回收，通过并发标记和并发清除来最大限度地减少垃圾回收对应用程序的影响。同时，新生代的回收由其他垃圾回收器（如ParNew）负责。

### 介绍一下对象的创建过程?

```java
// 方法区  栈       堆
   Person p1 = new Person();
```

答：

1. 类加载：当Java虚拟机需要使用一个类时，会首先检查是否已经加载过该类。如果尚未加载，则会通过类加载器加载该类的二进制字节码文件，并在内存中创建一个Class对象来表示该类。
   
   - 加载：加载字节码文件到内存中，并存储在方法区的运行时常量池中，然后将其转换为一个与目标类型对应的java.lang.Class对象实例。
   
   - 链接：防止恶意代码的执行。
     
     - 验证：确保 Class 文件的字节流中包含的信息符合约束要求。
     
     - 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，并为类中的所有静态变量分配内存空间。（静态变量，默认值；被final修饰的static变量（常量），会直接赋值）
     
     - 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。（举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。）
   
   - 初始化：执行static代码块，为静态变量赋值

> 最终，方法区会存储当前类类信息，包括类的静态变量、类初始化代码（定义静态变量时的赋值语句 和 静态初始化代码块）、实例变量定义、实例初始化代码（定义实例变量时的赋值语句实例代码块和构造方法）和实例方法，还有父类的类信息引用。

2. 分配内存：在类加载完成后，Java虚拟机会为对象在堆内存中分配空间。根据对象的大小和特定的内存分配算法，Java虚拟机会选择合适的内存区域来分配对象。

3. 初始化实例变量：在分配内存后，Java虚拟机会将对象的实例变量初始化为默认值，例如，整型变量会被初始化为0，引用类型变量会被初始化为null。

4. 设置对象头：Java虚拟机会在对象的内存空间中额外保存一些信息，例如对象的类型、同步锁状态、GC标记等。这些信息组成了对象头。

5. 执行构造函数：在对象的实例变量初始化完成后，Java虚拟机会调用对象的构造函数来对对象进行进一步的初始化，例如，为实例变量赋予特定的初值或执行其他初始化操作。（`{}`也会得到执行，但原始构造方法内的代码总是最后执行）

6. 对象创建完成。

### 介绍一下类加载的详细过程?

答：

> 加载 -> 链接（验证 -> 准备 -> 解析） -> 初始化

1. 加载：类加载的第一步是加载类的字节码文件。当Java程序需要使用一个类时，Java虚拟机会通过类加载器查找该类的字节码文件，并将其加载到内存中。字节码文件可以来自本地文件系统、网络、ZIP文件等。

2. 验证：在加载字节码文件到内存之前，Java虚拟机会对字节码文件进行验证，以确保其符合Java虚拟机规范和安全性要求。验证过程包括文件格式验证、元数据验证、字节码验证和符号引用验证等。

3. 准备：在准备阶段，Java虚拟机为**类的静态变量**分配内存，并初始化为默认值（例如，数值类型初始化为0，对象引用初始化为null等）。注意，这里只是分配内存，并不会进行赋值操作。

4. 解析：解析阶段是将类的符号引用转换为直接引用的过程。符号引用是指用类的全限定名来表示类、方法、字段等的引用，而直接引用是指指向内存中实际对象的指针或偏移量。解析过程将符号引用解析为直接引用，以便在后续的运行期间直接使用。

5. 初始化：在准备阶段，Java虚拟机为类的静态变量赋予默认值，在初始化阶段，才会执行类的静态初始化代码块。静态初始化代码块是类中用static关键字声明的代码块，用于初始化类的静态变量。初始化阶段是类加载过程的最后一步，也是类加载的触发点。

### 引用和对象分别是什么时候被GC的?

答：

- 对象的GC时机：
  
  - 当对象不再被任何活动线程引用时，即对象不可达时，垃圾回收器会标记该对象为垃圾，并在适当的时机进行回收。Java虚拟机中的垃圾回收器会通过跟踪引用链来判断对象是否可达，如果对象不可达，则认为该对象是垃圾，可以被回收。

- 引用的GC时机：引用指的是指向对象的指针，它们可以被用于检测对象是否还存活。Java中有四种类型的引用：强引用、软引用、弱引用和虚引用。（实际上是五种，还有终结器引用）不同类型的引用在GC时机上有所区别。
  
  - **强引用（Strong Reference）**：如果一个对象有强引用与之关联，即使在内存不足时，垃圾回收器也不会回收该对象，保证对象不会被GC。只有当所有强引用都不存在时，该对象才会被回收。
  
  ```java
  Object strongReference = new Object();
  ......
  strongReference = null;
  ```
  
  - **软引用（Soft Reference）**：当内存不足时，垃圾回收器可能会回收被软引用引用的对象。软引用通常用于实现内存敏感的缓存等场景。配合引用队列使用可以回收引用本身。
  
  ```java
  String str = new String("abc");
  SoftReference<String> softReference = new SoftReference<String>(str);
  ```
  
  - **弱引用（Weak Reference）**：弱引用与软引用类似，但更弱一些。即使内存不紧张，只要垃圾回收器发现某个对象只有弱引用与之关联，就会将该对象回收。配合引用队列使用可以回收引用本身。
  
  ```java
  String str = new String("abc");
  WeakReference<String> weakReference = new WeakReference<>(str);
  ```
  
  - **虚引用（Phantom Reference）**：虚引用是最弱的一种引用，它不能用于获取对象的实例，也不能通过虚引用来获取对象的引用。虚引用的目的是在对象被回收时，收到一个系统通知。必须配合引用队列使用。
  
  ```java
  String str = new String("abc");
  ReferenceQueue queue = new ReferenceQueu();
  // 创建虚引用，要求必须与一个引用队列关联
  PhantomReference pr = new PhantomReference(str,queue);
  ```

### 介绍一下GC过程以及为什么要分代GC?

答：以CMS垃圾回收器为例说一下GC过程。CMS采用复制（新生代）+标记清除（老年代）。

- 老年代GC：
  
  - 1、 初始标记：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快；
  
  - 2、 并发标记：同时开启 GC 和用户线程，用一个闭包结构（可以是图、链表、树等形式）去记录可达对象。在这个阶段，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
  
  - 3、 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段的时间稍长，但远远比并发标记阶段时间短。
  
  - 4、 并发清理：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

分代GC是一种优化策略，将Java堆内存划分为不同的代（Generation），并根据对象的生命周期将对象分配到不同的代中。通常将Java堆分为新生代（Young Generation）、老年代（Old Generation）和永久代（Permanent Generation，JDK1.7）。

而分代GC的原因是大部分对象的生命周期是短暂的，只有少部分对象会存活较长时间。通过将对象分配到不同的代中，可以针对不同代采取不同的垃圾回收策略，从而提高垃圾回收的效率。

比如新生代使用复制算法进行回收，因为新生代对象的生命周期短，复制算法可以迅速回收垃圾。而老年代使用标记-清除或标记-整理算法进行回收，因为老年代对象的生命周期长，需要较为复杂的算法来回收垃圾。

分代GC的优势在于可以根据对象的生命周期采用不同的回收策略，从而提高垃圾回收的效率和性能。同时，分代GC还可以避免全局垃圾回收导致的长时间停顿，提高应用程序的响应速度。

### 介绍一下G1和CMS?

答：

- G1（Garbage-First）：同时注重吞吐量和低延迟，适用于超大堆内存，整体上是标记+整理算法，但两个区域之间是复制算法。
  
  - 大致分为四个步骤：初始标记（stw）、并发标记、最终标记（stw）、筛选回收（stw）。

- CMS（Concurrent Mark Sweep）收集器是一种尽可能让单次STW的时间最短的收集器。
  
  - 优点：并发收集、低停顿。
  
  - 缺点：
    
    - 对 CPU 资源敏感
    
    - 无法处理浮动垃圾
    
    - 它使用的回收算法-`标记-清除`算法会导致收集结束时会有大量空间碎片产生

## JUC

### 简述线程安全的活跃性问题，竞态条件是怎么产生的，如何避免死锁?

答：

1. 线程安全的活跃性问题主要涉及三类问题：死锁、活锁和饥饿。
   
   - 死锁：死锁是指两个或多个线程相互等待对方释放锁，导致程序无法继续执行的情况。
   
   - 活锁：两个线程改变对方的结束条件。线程之间存在竞争条件，导致资源的状态不断变化，使得线程无法成功获取资源。
   
   - 饥饿：生产者生产速度跟不上消费者消费速度。

2. 多个线程在临界区（一段代码块内如果存在对共享资源的多线程读写操作，则称这段代码块为临界区）内执行，由于代码的执行序列不同而导致结果无法预测。

3. 破坏锁竞争、避免使用多把锁、顺序加锁、避免嵌套锁、使用JUC并发工具包（如ReentrantLock.tryLock()）...

### 说明线程状态切换?

答：

1. `NEW`：线程对象被创建，但还没有调用start()方法启动线程。

2. `RUNNABLE`：线程调用start()方法后，进入可运行状态，表示线程正在JVM中运行或等待CPU时间片。

3. `BLOCKED`：等待IO操作、等待获取锁等。

4. `WAITING`：
   
   - 进入`WAITING`：wait()、join()、park()...
   
   - 进入`BLOCKED`：调用notify()、notifyAll()、interrupt()唤醒后，但是竞争锁失败。
   
   - 回到`RUNNABLE`：notify()、notifyAll()、interrupt()、unppark()...

5. `TIMED_WAITING`
   
   - 进入`TIMED_WAITING`：wait(n)、join(n)、sleep(n)、parkNanos()、parkUnit()...
   
   - 进入`BLOCKED`：调用notify()、notifyAll()、interrupt()唤醒后，但是竞争锁失败。
   
   - 回到`RUNNABLE`：notify()、notifyAll()、interrupt()、unppark()...

6. `TERMINATED`：线程执行完了所有的代码或者发生了未捕获的异常导致线程终止。

### 多少线程合适，在项目中如何考虑?

答：

1. CPU 密集型运算：通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶替，保证 CPU 的时钟周期不被浪费。

2. IO 密集型运算：经验公式：`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间`。（简单理解就是2n（n是CPU核数））

### 说明synchronized底层实现，以及和Lock的区别?

答：

synchronized的底层实现主要涉及对象头和monitor锁。

从字节码角度说的话，底层使用（管程或者叫监视器）monitorenter、monitorexit将同步块包起来。

将Monitor与锁对象关联。将Owner设置为抢占到锁的线程，后续再有线程来获取锁，先进入EntryList等待。在WaitSet中等待的线程，如果条件满足了则会进入EntryList等待获取锁。

优化：更底层一点就是，在对象头添加一些标记位来表示锁的状态。无锁的标记位是001，偏向锁的标记位是101，轻量级锁的标记位是00，重量级锁的标记位是10。

- 偏向锁会将线程ID设置到对象的 Mark Word 中。

- 轻量级锁会在当前线程的栈帧创建一块空间用于存储锁记录（lock record），把对象头中的Mark Word复制到锁记录中，拷贝成功后，虚拟机将使用CAS操作将对象Mark Word更新为指向Lock Record的指针。并将Lock Record里的owner指针指向对象的Mark Word。

与 synchronized 一样，都支持可重入。但不同的是ReentrantLock支持可中断、可以设置超时时间、可以设置公平锁、支持多个条件变量。且ReentrantLock是基于AQS（AbstractQueuedSynchronizer）实现的

而 AQS 是用 CLH（Craig,Landin,and Hagersten） 队列锁 实现的。

### 说明ThreadLocal的底层实现，以及实现的数据结构?

### volatile的可见性和禁止指令重排是怎么实现的，有几种屏障?

### 说明ConcurrentHashMap的底层原理?

### 说明线程池创建的流程?

### 用过线程池吗?

## 网络通信

### 怎么样才能确定一个连接?

### 说明一下一个请求的完整流程?

### TCP为什么要三次握手，两次不行吗?

### TCP粘包是怎么产生的，如何解决?

### 介绍一下bio、nio、aio以及Netty的模型?

### TCP的空白连接占用多少内存?

### TCP协议握手挥手，为什么有time_wait?

## Netty

### 为什么会有粘包的情况?Netty如何而处理粘包半包?

### Netty长连接如何做keeplive的?

## Spring

### Spring自动装配Bean有哪些方式?

### 说明Spring refresh流程?

### Spring事务失效常见有哪些?

### Spring中的设计模式有哪些，平时有用到吗?

## SpringBoot

### 说明SpringBoot自动装配原理?

### 说明SpringBoot的@Condition的实现原理?

## MyBatis

### 说明MyBatis的执行流程和底层实现?

### 如果数据库进行修改了，Mybatis的缓存怎么办?

## Dubbo

### 介绍一下Dubbo的核心功能?

### 介绍一下Dubbo的核心组件?

### 采用注册中心的好处?

### 介绍一下Dubbo的流程以及默认序列化方式?

### 说一下Dubbo服务的启动、注册流程?

## Redis

### Redis底层的数据结构?

### 说一下Redis在项目中的使用?

### 介绍一下缓存雪崩、穿透、击穿的场景和对应的解决方案?（Redis中可能存在的问题）

### 介绍一下缓存一致性的问题?

### Redis会不会丢失数据?

### 介绍一下Redis的主从复制?

### Redis有哪几种缓冲区?

## MySQL

### 说明一下联合索引?

### 说明InnoDB和MylSam的区别，及使用场景?

### 数据库和Redis的一致性问题怎么解决的，如何保证强一致性?

### MySQL中是怎么保证ACID的?

## Kafka

### 为什么用Kafka?

### 如何保证消息的顺序性?

### 如何避免消息的重复消费?

### 延迟消息的使用场景是什么，oneway了解吗?

### 如何解决消息挤压?

## 场景题

### 说一下秒杀的实现?

### 说一下多个系统之间的调用方式以及可能出现的问题?

### 说一下项目中遇到的困难?

### 说一下限流的常见算法?

### 高并发的处理方法?

## 运维

### Linux、CPU以及IO优化都是怎么做的?

### 异地多机房容灾架构怎么保证数据同步?

### 数据冷备份的方案是什么?

### 生产环境上如何快速定位并解决问题?

### 如果一个系统2分钟内的CPU非常大，如何处理，如何解决?

### 项目如何承载高并访问?（架构）

> Nginx负载 + Redis缓存 + 异步处理

## 算法

## 系统指标

## 项目

### 一台机器，Netty能建立多少连接?（结合网关项目：http进，dubbo出，各个能支持多少连接?）

### 网关项目的编解码器如何实现

## 附录

> JDK1.7：-Xss1m -Xms1024m -Xmx2048m -Xmn345m -XX:SurvivorRatio=8 -XX:PermSize=256m -XX:MaxPermSize=512m
> 
> JDK1.8：-Xss1m -Xms1024m -Xmx2048m -Xmn345m -XX:SurvivorRatio=8 -XX:MaxMetaspaceSize=512m 